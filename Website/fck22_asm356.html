<!--Website for Fred Kummer and Amardeep Manak
Thanks to Gautham Ponnu for the template!
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<html>
<head>

	<title>ECE 5725 | Goodnight Pi </title>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />

	<meta name="keywords" content="Fred Kummer, Amardeep Manak, Goodnight Pi, Raspberry Pi, Power Control, ATMEGA, I2C, SPI, RTC" />
	<meta name="description" content="This is the webpage for Fred Kummers and Amardeep Manaks final project for ECE 5725, the Goodnight Pi." />
	<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/2.7.0/build/reset-fonts-grids/reset-fonts-grids.css" media="all" />
	<link rel="stylesheet" type="text/css" href="CSS/report.css" media="all" />
	<link rel="stylesheet" href="CSS/project.css" type="text/css" media="screen, projection" />
</head>
<body>

<div id="doc2" class="yui-t7">
	<div id="inner">
		<div id="hd">
			<div class="yui-gc">
				<div class="yui-u first">
					<h1>Goodnight Pi: Reducing Raspberry Pi Power Consumption</h1>
					<h2>Fred Kummer and Amardeep Manak</h2>
				</div>

			</div><!--// .yui-gc -->
		</div><!--// hd -->

		<div id="bd"> <!--// Main Body begins here -->
			<div id="yui-main">
				<div class="yui-b">


						<div class="yui-gf"> <!--// This is a section -->
							<div class="yui-u first">
								<h2>Introduction</h2> <!--// put your heading here -->
							</div>
							<div class="yui-u">
								<img src="images/team.jpg" style = "float:right; margin: 10px 10px 10px 10px;" alt="" width="40%" height="40%" title="The team with the Goodnight Pi"/>
								<p> The Raspberry Pi is a powerful platform to build a variety of projects on.
									Its full Linux operating system and large variety of peripherals make it extremely useful for a large variety of projects that a traditional microcontroller could not handle.
									However, the Raspberry Pi has high power consumption, even when idle making it difficult to use in many applications that must be able to last for long periods on battery power or in any low-power situation.
									The Raspberry Pi also includes no native support for any kind of low power or sleep mode, meaning that there is no way to mitigate this issue without additional hardware.
									To be able to deploy Raspberry Pi's in outdoor or any low-power, long-term applications, additional power control and management hardware is needed.
								</p> <!--// Put Content here -->

								<br/>

								<p>To address this issue we created a project that interefaces witht the Raspberry Pi and manages its power consumption by scheduling when it should be on and off. This project integrates the popular ATMEGA328
								,power control circuitry, and a real-time-clock (RTC) with the Raspberry Pi. This allows the ATMEGA328P to control power to the Raspberry Pi, turning it off wwhen it is done with its application and turning it back
							   on when its need to run again. The scheduling for powering on the Raspberry Pi can be based on timing or external events that are used to generate interrupts. By having the Raspberry Pi spend a significant portion of its
							 	time powered off instead of sitting idle, a great deal of power can be saved.</p>

								<p> <br/>

								</p>
							</div>
						</div><!--// Your section has ended -->

						<div class="yui-gf"> <!--// This is another section -->
							<div class="yui-u first">
								<h2>Objective</h2> <!--// put your heading here -->
							</div>
							<div class="yui-u">
								<p> The goal of this project is to develop a low cost device that can be integrated with the Raspberry Pi to reduce power consumption by allowing the Pi to turn on and off based on a timed schedule or external events.
										This would allow the Raspberry Pi to be used in a wider variety of applications. Specifically, outdoor environmental data collection projects were the motivation for this system.
										With improved power management these projects could be left to collect data for a long period of time using the Raspberry Pi without losing power.
								</p> <!--// Put Content here -->
							</div>
						</div><!--// Your section has ended -->

						<div class="yui-gf"> <!--// This is a section -->
							<div class="yui-u first">
								<h2>Design</h2> <!--// put your heading here -->
							</div>
							<div class="yui-u">
								<p><h2><strong>Design Overview</strong></h2></p>
								<p>
								At a high level the design consists of four major hardware components. These are the Raspberry Pi itself, the ATMEGA328P, the RTC, and the Power Control Circuit. The Raspberry Pi wakes up when the ATMEGA328P provides it with power,
								and performs some action or series of actions based on why it was woken up. It then shuts itself down and alerts the ATMEGA that it can turn off power to the Pi. The Raspberry Pi and ATMEGA communicate with a custom protocol using SPI. The ATMEGA tracks
								the state of the Raspberry Pi and determines if it should be powered on or turned off. It determines this based on the time provided by the RTC and the state of its interrupt pins. The ATMEGA and the RTC communicate using I2C. The time interval and interrupts that should be able
								to trigger the ATMEGA to wake up the Raspberry Pi can be configured using a GUI on the Raspberry Pi. The ATMEGA then sets the state of the Power Control Circuit to control the power to the Raspberry Pi. Once configured and running, the system continuously cycles through a sequence
								of turning the Raspberry Pi on, letting it complete whatever application is desired, and shutting down the Pi again until the time interval expires or an interrrupt arives. A high level view of the system components is caputred in the block diagram below.
								</p>
								<center><img src="images/block.jpg" alt="" width="70%" height="70%" title="Block Diagram of System"/></center>
								<br/>
								<p><h2><strong>Hardware</strong></h2></p>
								<br/>
							  <p><h3><strong>ATMEGA328P</strong></h3></p>
								<br/>
								<p>The ATMEGA328P was used to control the power of the Raspberry Pi. This microcontroller was chosen because it can operate with far less power than a Raspberry Pi, is relatively inexpensive, and has extensive support and documentation because of its uses in the Arduino.
								Even though a stand-alone ATMEGA328P was used, all existing Arduino libraries could be used, making development much simpler. The ATMEGA328P also offers a diverse range of peripherals. It has external interrupts and is capable of communicating using both SPI and I2C, all of
								which were all necessary functions for this project. Below is a picture of the ATMEGA integrated into the system.</p>
								<center><img src="images/atmega.jpg" alt="" width="70%" height="70%" title="The ATMEGA in our system"/></center>
								<br/>
								<p>The ATMEGA328P was run at 3.3V and 8 MHz. In an Arduino it is typically run at 5V and 16 MHz, but this requires significantly more power. The lower frequency and voltage sacrificed performance to conserve energy, but the performance of the ATMEGA was still more than sufficient
									for this application. The ATMEGA only drew 3 mA while running, a significant improvement over the 210 mA that the Rasbperry Pi drew when idle.  A schematic for the setup of the ATMEGA can be seen below. </p>
									<center><img src="images/at_circ.jpg" alt="" width="70%" height="70%" title="Connections between the ATMEGA and the Pi"/></center>
								<br/>

								<p> The ATMEGA communicated with the Raspberry Pi using SPI, serving as the slave. The ATMEGA also connected to a GPIO pin on the Raspberry Pi that was configured to always output a high signal. When this pin went low, it indicated that the Raspberry Pi had shutdown, and when it went
								high again it indicated that the Raspberry Pi had turned back on successfully. This prevented any premature cycling of power, allowing the ATMEGA to track the exact state of the Raspberry Pi. The diagram below illustrates the connections between the Raspberry Pi and the ATMEGA.</p>
								<center><img src="images/at_spi.jpg" alt="" width="70%" height="70%" title="Connections between the ATMEGA and the Pi"/></center>

								<p>Whenever the Raspberry Pi sent a request to the the ATMEGA, it would process the request and send back the appropriate response as specified by the communication protocol (see the Protocol section for more information). The ATMEGA could be configured
								to trigger wakeup of the Raspberry Pi from three different sources: a timer, external interrupt 0, and external interrupt 1. The timer could be set to various time intervals, and was constantly checked by querying the RTC for the current time and comparing that
								to the time the timer began. If the appropriate amount of time had passed since the Pi powered down, the ATMEGA would wake the Pi back up. External interrupt 0 and external interrupt 1 on the ATMEGA could also be configured to trigger a wakeup on a rising edge.
							 	Any type of hardware can be attached to these interrupt pins, it simply needs to be able to generate a rising edge at the desired time. For example, in the example application built for this project interrupt 0 was attached to a button and interrupt 1 was attached to a voltage
								divider with a photoresistor. This allowed the Pi to be woken up at any time by a user pressing the button or by increasing the light level on the photoresistor. These interrupts could be used for a wide variety of applications, such as waking the Pi up when something gets within a certain proximity
							  or based on a variety of environmental factors, such as temperature or light. The ATMEGA controlled the power to the Raspberry Pi by simply changing the state of a GPIO pin that connected to the Power Control Circuit</p>
								</p> <!--// Put Content here -->
								<br/>
								<p><h3><strong>Raspberry Pi</strong></h3></p>
								<p>The Raspberry Pi 2 Model B was used for the project, though none of the functionality of the project relies specifically on special features of this model. Theoretically the project could be easily transferred to different models of the Raspberry Pi.
								The Raspberry Pi did not require any special hardware modification, but some of its GPIO pins had to be reserved to connect with the ATMEGA. The physical pins that were used on the Pi and their function is listed below.</p>
								<center><table border="1" width="300" height="150" font-size= "6">
								<tr align = "center">
									<td><strong>Raspberry Pi Physical Pin</strong></td>
									<td><strong>Function</strong></td>
								</tr>
								<tr align = "center">
								<td>Pin 2</td>
								<td>5V Input</td>
								</tr>
								<tr align = "center">
								<td>Pin 6</td>
								<td>Ground</td>
								</tr>
								<tr align = "center">
								<td>Pin 16</td>
								<td>Alive Signal</td>
								</tr>
								<tr align = "center">
								<td>Pin 19</td>
								<td>MOSI</td>
							</tr>
								<tr align = "center">
								<td>Pin 21</td>
								<td>MISO</td>
								</tr>
								<tr align = "center">
								<td>Pin 23</td>
								<td>SCLK</td>
								</tr>
								<tr align = "center">
								<td>Pin 26</td>
								<td>SS</td>
							</tr>
							</table></center>
								<br/>

								<p><h3><strong>Power Control Circuit</strong></h3></p>

								<p> The Power Control Circuit allowed the ATMEGA to switch 5V to power the the Pi using a 3.3V signal from the ATMEGA's GPIO pin. Also, since power was being provided to the Pi through its 5V pin and bypassing the protection circuitry
									provided on the Pi itself, this protection circuitry was recreated. This consisted of a 2A quick-blow fuse, a diode to prevent reversed current flow, and a 1 uF decoupling capacitor. Two transistors were used to switch power to the Pi, one NFET
									and one PFET. The FQP30N06L was used as the NFET and the FQP27P06 was used as the PFET. Two of them were used for level-shifting and inversion, allowing a 3.3V signal to safely control 5V and allowing power to be connected only when the signal was
									high. A schematic of the power control circuit is shown below.</p>
									<center><img src="images/pcu.jpg" alt="" width="70%" height="70%" title="Power Control Circuit"/></center>
								<br/>

								<p><h3><strong>RTC</strong></h3></p>

								<p>
									The RTC used was the DS1307, and more specifically the DS1307 breakout board from Adafruit was used for this project. The hardware setup for this component was extremely simple. The RTC was powered by 5V, but was able to communicate with the ATMEGA
									successfully using 3.3V logic. It communicated with the ATMEGA using I2C, and so connected to it through the SDA and SCL pins, which are pins 27 and 28 on the ATMEGA respectively. The SQW pin of the DS1307 was unused.
									A schematic of the RTC setup can be seen below.
									<center><img src="images/rtc.jpg" alt="" width="70%" height="70%" title="RTC Schematic"/></center>
							  </p>

								<p><h3><strong>Application and Interrupt Hardware</strong></h3></p>
								<p>
									For demonstrating this project, some application specific hardware was used to give the Raspberry Pi something to do when it woke and to provide ways to trigger then interrupts. The Ping Ultrasonic Distance Sensor from Parallax
									was used with the Rasbperry Pi to simulate measuring river depth, and this simply required two GPIO pins on the Pi. A button was connected to interrupt 0 of the ATMEGA to serve as one of the interrupt sources, demonstrating the use of
									user input as a means of waking up the Raspberry Pi. A voltage divider that included a phototresistor was connected to interrupt 1 on the ATMEGA to demonstrate the use of environmental sensors to trigger interrupts. This setup would trigger
									the interrup ton the ATMEGA whenever the light levels on the photoresistor rose above a certain threshold.
								</p>
								<br/>
								<p><h3><strong>Complete Circuit</strong></h3></p>



								<p>A full schematic for the hardware of the project is shown below. Note that this excludes the application specific hardware, such as the ultrasonic sensor and interrupt sources, as they are highly application specfic and were merely for demonstration purposes.
								The full circuit assembled for the demo is also shown below.</p>
								<center><img src="images/full_schem.jpg" alt="" width="100%" height="100%" title="Full Schematic"/></center>


								<p><h2><strong>Software</strong></h2></p>
								</br>
								<p><h3><strong>GUI</strong></h3></p>
								<p>
									For designing the GUI of the project, there were a few alternative options to Pygame which were considered. QtCreator was considered but its files had to downloaded and it takes 8 hours to compile it. With time constraints, Pygame was eventually chosen to be the tool for designing the GUI. </p> </br>

								<p>
The 2 main requirements for the GUI were that the user could select a time interval and toggle the external interrupts. The toggling of the interrupts can be done by buttons on the GUI which are simple enough to implement. For the time interval, the initial plan was to have a textbox in which the user could enter minutes starting from a minimum of 1 minute to maximum of 1440 minutes (24 hours). The implementation for the text box turned out to be complex as every character which is typed out has to be displayed on every loop iteration. This means all the characters typed have to be stored and dynamically deleted if the user enters the backspace key. To be user friendly a cursor would also be required and this would further complicate the design. </p> </br>

								<p>
Keeping the above complexity in mind, a drop down menu was selected for the time interval. Again a proper drop down would be difficult to implement fully in PyGame so a compromise was reached, there wouldn't be a drop down but the intervals could be iterated through by the user using the up/down arrow keys. The disadvantage of using this over the text box was that there could only be a limited options to select from for the user unlike the fully customizable minutes in the text box. </p> </br>

								<p>
After getting all the desired functionality, the next step was to integrate the C++ code and the GUI. This turned out to be more difficult than was initially thought but an elegant solution was still found in the end. Now when the user presses the enter key for selecting the time interval, the corresponding C++ function has to be called for sending the config packets to the Atmega328P. Now C++ functions cannot be directly called in python scripts. So the options to do that were extending python which is adding support so that a C++ library could be imported or using the ctypes library to import C code (there is workaround for using ctypes with C++). Now for extending python, python wrappers have to be created in the C++ files for exporting them. These wrappers are available from the <python.h> header file. After compiling the wrappers and C++ files a C++ library is created which has an extension of .so and can be imported to python. This library gave errors when the python script was run from the terminal. The ctypes library was also tried but gave errors too. Finally a solution was reached where the executable of C++ was called in the python script via the os.system call. For this a separate C++ wrapper file had to be created called guiMain.cpp which accepted command line arguments. These had to be made so that the wrapper could differentiate between the functionalities like the time interval, ping and the external interrupts. </p> </br>

								<p>
When the time interval was successfully configured the Atmega sent a packet back which signalled success to the Pi. This packet was processed in the guiMain.cpp file and config success!!! text was written into a .txt file. The gui would poll this file and print Config Success!! on the screen when it read the text. After reading the text, it was deleted and the file closed. The success message on the screen lasted for 5 seconds. The Ping success message was implemented in a similar way described above.									
								</p> </br>
								
								<p><h3><strong>Real Time Clock</strong></h3></p>
								
								<p>
										The Real Time Clock is a critical component for the project. The Atmega328P does not have an internal RTC and hence the need for an external module. The module selected for the project was a DS1307 even though it is slightly expensive at $7.95. The advantage of using it is having a really easy to use breakout board with a crystal, RTC chip, capacitors and the battery holder ready to be soldered on a ready made board. The RTC uses I2C to interface with the Atmega328P.
								</p> </br>

								<p>
The microcontroller receives the time interval in the form of seconds from the Raspberry Pi and stores it. When a power cycle is going on,the microcontroller reads the epoch time from the RTC which is also in seconds and compares it with the time configured. This is implemented as a poll in the main loop. When the time is greater than interval, the Pi is woken up.
								</p> </br>
								
								<p><h3><strong>Handshaking Protocol Between the Atmega328P and Raspberry Pi 2</strong></h3></p>
								<p>
										The communication between the Raspberry Pi 2 and Atmega328P happens through SPI. The protocol has been designed to have 11 packets being sent from Pi-Arduino and from Arduino-Pi. Now the Atmega328P has only a single SPI buffer and hence there is a unified interrupt for receive and transmit. To discriminate between receive and transmit, a start byte is used by the Raspberry Pi to enable a global variable in the Atmega which keeps track of whether a packet is being received or transmitted. </p> </br>
								
								<p>
										The packet is divided into a opcode byte and the payload bytes. The opcode gives information about what the packet is about. For example an opcode 0x01 corresponds to the wake response from the arduino to the Pi. </p> </br>
								
								<p>
										The different packets are given below with a short description for each:  </br> </br>
										<center><img src="images/WAKE_Req.jpg" alt="" title="Wake Request Packet"/></center> </br> </br>
										
										The wake request packet is sent from the Pi to the Atmega328P and is basically a request for the reason for its wakeup. The start byte is 0xFE and the opcode is 0x00. </br> </br>
										
										<center><img src="images/WAKE_RESP.jpg" alt="" title="Wake Response Packet"/></center> </br> </br>
										
										The wake response is the packet sent from the Atmega to the Pi in response to the wake request. The opcode is 0x01. Time interval takes up 4 bytes because it's a long variable at both ends. The INT0 and INT1 are simple toggle bits and hence take up 1 byte each. The rest of the packets are empty. </br> </br>
										
										<center><img src="images/SLEEP_REQ.jpg" alt="" title="Sleep Request Packet"/></center> </br> </br>
										
										The sleep request is a packet which informs the Atmega that the Pi is going to shut itself down. </br> </br>
										
										<center><img src="images/SLEEP_RESP.jpg" alt="" title="Sleep Response Packet"/></center> </br> </br>
										
										The sleep response packet is the acknowledgement from the Atmega in response to the sleep request. </br> </br>
										
										<center><img src="images/CONFIG_REQ.jpg" alt="" width="99%" height="99%" title="Config Request Packet"/></center> </br> </br>
										
										The config request is the packet which is sent when the user has made a configuration change from the GUI. The "INT0 type" and "INT1 type" are currently not in use. They can be configured for falling, rising interrupts in the future. If only the time interval is being sent, then 0s are sent in all the other sections. </br> </br>
										
										<center><img src="images/CONFIG_RESP.jpg" alt="" title="Config Response Packet"/></center> </br> </br>
										
										The config response packet is the acknowledgement from the Atmega from the Pi for the config request. </br> </br>
										
										<center><img src="images/PING_REQ.jpg" alt="" title="Ping Request Packet"/></center> </br> </br>
										
										The ping request is the message from the Pi to the Atmega to check whether the communication between the two are working. </br> </br>
										
										<center><img src="images/PING_RESP.jpg" alt="" title="Ping Response Packet"/></center> </br> </br>
										
										The ping response is the acknowledgement for the ping request. </br> </br>
										
										<center><img src="images/JUNK_PKT.png" alt="" title="Junk Packet"/></center> </br> </br>
										
										The junk packet is used by the master i.e. the Raspberry Pi to send clock pulses to its slave so that it can transmit its response. It is filled up with 0xFF.  </br> </br>
										
								</p>		
								
								<br/>
							</div>


						</div><!--// Your section has ended -->


						<div class="yui-gf"> <!--// This is a section -->
							<div class="yui-u first">
								<h2>Testing</h2> <!--// put your heading here -->
							</div>
							<div class="yui-u">
								<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
								</p> <!--// Put Content here -->
							</div>
						</div><!--// Your section has ended -->

						<div class="yui-gf"> <!--// This is a section -->
							<div class="yui-u first">
								<h2>Drawings</h2> <!--// put your heading here -->
							</div>
							<div class="yui-u">
								<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
								</p> <br /> <p> This is an example image  </p> <!--// Put Content here -->
								<img src="images/incident.png" title="Ha Ha ... that's me" alt="This is a picture" width="420" height="200"/> </p>
								<p> Credits to XKCD </p>
							</div>
						</div><!--// Your section has ended -->

						<div class="yui-gf"> <!--// This is a section -->
							<div class="yui-u first">
								<h2>Results</h2> <!--// put your heading here -->
							</div>
							<div class="yui-u">
								<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
								</p> <!--// Put Content here -->
							</div>
						</div><!--// Your section has ended -->

						<div class="yui-gf"> <!--// This is a section -->
							<div class="yui-u first">
								<h2>Conclusion</h2> <!--// put your heading here -->
							</div>
							<div class="yui-u">
								<p>Yay !!! Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
								</p> <!--// Put Content here -->
							</div>
						</div><!--// Your section has ended -->

					<div class="yui-gf">
						<div class="yui-u first">
							<h2>Code Appendix</h2>
						</div>
							<div class="yui-u">
							<!-- This is a good idea. HTML generated using hilite.me -->
							<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #333333">*</span>
 <span style="color: #333333">*</span> blink.c<span style="color: #333333">:</span>
 <span style="color: #333333">*</span>      blinks the first LED
 <span style="color: #333333">*</span>      Gordon Henderson, projects<span style="color: #FF0000; background-color: #FFAAAA">@</span>drogon.net
 <span style="color: #FF0000; background-color: #FFAAAA">*/</span>

<span style="color: #557799">#include &lt;stdio.h&gt;</span>
<span style="color: #557799">#include &lt;wiringPi.h&gt;</span>

<span style="color: #333399; font-weight: bold">int</span> main (<span style="color: #333399; font-weight: bold">void</span>)
{
  printf (<span style="background-color: #fff0f0">&quot;Raspberry Pi blink</span><span style="color: #666666; font-weight: bold; background-color: #fff0f0">\n</span><span style="background-color: #fff0f0">&quot;</span>) ;

  <span style="color: #008800; font-weight: bold">if</span> (wiringPiSetup () <span style="color: #333333">==</span> <span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>)
    <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">1</span> ;

  pinMode (<span style="color: #0000DD; font-weight: bold">0</span>, OUTPUT) ;         <span style="color: #888888">// aka BCM_GPIO pin 17</span>

  <span style="color: #008800; font-weight: bold">for</span> (;;)
  {
    digitalWrite (<span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #0000DD; font-weight: bold">1</span>) ;       <span style="color: #888888">// On</span>
    delay (<span style="color: #0000DD; font-weight: bold">500</span>) ;               <span style="color: #888888">// mS</span>
    digitalWrite (<span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #0000DD; font-weight: bold">0</span>) ;       <span style="color: #888888">// Off</span>
    delay (<span style="color: #0000DD; font-weight: bold">500</span>) ;
  }
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span> ;
}
</pre></td></tr></table></div>

						</div>
					</div>
					</div>

					<div class="yui-gf">
						<div class="yui-u first">
							<h2>Contact</h2>
						</div>
						<div class="yui-u">
						<p> Your good names. Probably Acknowledgments and Thanks </p>
						</div>
					</div>
					</div>

				</div><!--// .yui-b -->
			</div><!--// yui-main -->
		</div><!--// bd -->

		<div id="ft">
			<p><a href="http://validator.w3.org/check?uri=referer"><img src=
			"images/w3chatered.gif" title="W3C+Hates+Me" alt="W3C+Hates+Me"
			width="80" height="15" /></a>
			<a href="http://jigsaw.w3.org/css-validator/check/referer"><img src=
			"images/css_copy.gif" title="Valid+CSS%21" alt="Valid+CSS%21"
			width="80" height="15" /></a>
			<img src="images/code.gif" title="Handcrafted with sweat and blood" alt="Handcrafted with sweat and blood" width="80" height="15" />
			<img src="images/anybrowser.gif" title="Run Any Browser Any OS" alt="Runs on Any Browser Any OS" width="80" height="15" /></p>
			<br />
		</div><!--// footer -->

	</div><!-- // inner -->


</div><!--// doc -->


</body>
</html>
